<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CEP Speck Streaming Protocol Browser Test</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: #f5f5f5;
      }
      .test-container {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .test-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      .test-status {
        padding: 4px 12px;
        border-radius: 4px;
        font-weight: 500;
        text-transform: uppercase;
        font-size: 12px;
      }
      .status-pending {
        background: #fef3c7;
        color: #92400e;
      }
      .status-running {
        background: #dbeafe;
        color: #1e40af;
      }
      .status-success {
        background: #d1fae5;
        color: #065f46;
      }
      .status-error {
        background: #fee2e2;
        color: #991b1b;
      }
      .test-controls {
        margin: 15px 0;
      }
      button {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        margin-right: 10px;
      }
      button:hover {
        background: #2563eb;
      }
      button:disabled {
        background: #9ca3af;
        cursor: not-allowed;
      }
      .results {
        background: #f9fafb;
        border-radius: 4px;
        padding: 15px;
        font-family: "Monaco", "Menlo", monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
      }
      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin: 15px 0;
      }
      .metric {
        background: #f3f4f6;
        padding: 10px;
        border-radius: 4px;
        text-align: center;
      }
      .metric-value {
        font-size: 24px;
        font-weight: bold;
        color: #1f2937;
      }
      .metric-label {
        font-size: 12px;
        color: #6b7280;
        text-transform: uppercase;
      }
      .browser-info {
        background: #eff6ff;
        border: 1px solid #dbeafe;
        border-radius: 4px;
        padding: 15px;
        margin-bottom: 20px;
      }
      .phase-indicator {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 11px;
        margin-right: 8px;
      }
      .phase-loading {
        background: #fef3c7;
      }
      .phase-generating {
        background: #dbeafe;
      }
      .phase-validating {
        background: #e0e7ff;
      }
      .phase-healing {
        background: #fce7f3;
      }
      .phase-done {
        background: #d1fae5;
      }
      .phase-error {
        background: #fee2e2;
      }
    </style>
  </head>
  <body>
    <h1>üß™ CEP Speck Streaming Protocol Browser Test</h1>

    <div class="browser-info">
      <h3>Browser Environment</h3>
      <div id="browser-info">Loading...</div>
    </div>

    <!-- Feature Compatibility Test -->
    <div class="test-container">
      <div class="test-header">
        <h3>üîß Feature Compatibility</h3>
        <span id="compatibility-status" class="test-status status-pending"
          >Pending</span
        >
      </div>
      <div class="test-controls">
        <button onclick="testCompatibility()">Test Compatibility</button>
      </div>
      <div
        id="compatibility-results"
        class="results"
        style="display: none"
      ></div>
    </div>

    <!-- Frame Protocol Test -->
    <div class="test-container">
      <div class="test-header">
        <h3>üì° Frame Protocol</h3>
        <span id="protocol-status" class="test-status status-pending"
          >Pending</span
        >
      </div>
      <div class="test-controls">
        <button onclick="testFrameProtocol()">Test Frame Protocol</button>
      </div>
      <div class="metrics" id="protocol-metrics" style="display: none">
        <div class="metric">
          <div class="metric-value" id="frames-created">0</div>
          <div class="metric-label">Frames Created</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="encoding-time">0ms</div>
          <div class="metric-label">Encoding Time</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="parse-time">0ms</div>
          <div class="metric-label">Parse Time</div>
        </div>
      </div>
      <div id="protocol-results" class="results" style="display: none"></div>
    </div>

    <!-- Network Simulation Test -->
    <div class="test-container">
      <div class="test-header">
        <h3>üåê Network Conditions</h3>
        <span id="network-status" class="test-status status-pending"
          >Pending</span
        >
      </div>
      <div class="test-controls">
        <button onclick="testNetworkConditions('fast')">Fast Network</button>
        <button onclick="testNetworkConditions('slow')">Slow Network</button>
        <button onclick="testNetworkConditions('unreliable')">
          Unreliable Network
        </button>
      </div>
      <div id="network-results" class="results" style="display: none"></div>
    </div>

    <!-- Memory Performance Test -->
    <div class="test-container">
      <div class="test-header">
        <h3>üíæ Memory Performance</h3>
        <span id="memory-status" class="test-status status-pending"
          >Pending</span
        >
      </div>
      <div class="test-controls">
        <button onclick="testMemoryPerformance()">Test Memory Usage</button>
        <button onclick="testLargeContent()">Large Content Test</button>
      </div>
      <div class="metrics" id="memory-metrics" style="display: none">
        <div class="metric">
          <div class="metric-value" id="memory-used">0MB</div>
          <div class="metric-label">Memory Used</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="memory-peak">0MB</div>
          <div class="metric-label">Peak Usage</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="gc-count">0</div>
          <div class="metric-label">GC Cycles</div>
        </div>
      </div>
      <div id="memory-results" class="results" style="display: none"></div>
    </div>

    <!-- Streaming Workflow Test -->
    <div class="test-container">
      <div class="test-header">
        <h3>üîÑ Live Streaming Test</h3>
        <span id="streaming-status" class="test-status status-pending"
          >Pending</span
        >
      </div>
      <div class="test-controls">
        <button onclick="testLiveStreaming()" id="streaming-button">
          Start Streaming Test
        </button>
      </div>
      <div id="streaming-phases" style="margin: 15px 0; display: none"></div>
      <div class="metrics" id="streaming-metrics" style="display: none">
        <div class="metric">
          <div class="metric-value" id="frames-received">0</div>
          <div class="metric-label">Frames Received</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="stream-duration">0ms</div>
          <div class="metric-label">Duration</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="frame-rate">0/s</div>
          <div class="metric-label">Frame Rate</div>
        </div>
      </div>
      <div
        id="streaming-content"
        class="results"
        style="display: none; max-height: 200px"
      ></div>
    </div>

    <script>
      // Browser Environment Detection
      function detectBrowserEnvironment() {
        const info = {
          userAgent: navigator.userAgent,
          vendor: navigator.vendor || "Unknown",
          language: navigator.language,
          platform: navigator.platform,
          cookieEnabled: navigator.cookieEnabled,
          onLine: navigator.onLine,
          memory: performance.memory
            ? {
                used: Math.round(
                  performance.memory.usedJSHeapSize / 1024 / 1024
                ),
                total: Math.round(
                  performance.memory.totalJSHeapSize / 1024 / 1024
                ),
                limit: Math.round(
                  performance.memory.jsHeapSizeLimit / 1024 / 1024
                ),
              }
            : null,
        };

        document.getElementById("browser-info").innerHTML = `
                <strong>User Agent:</strong> ${info.userAgent}<br>
                <strong>Vendor:</strong> ${info.vendor}<br>
                <strong>Platform:</strong> ${info.platform}<br>
                <strong>Language:</strong> ${info.language}<br>
                <strong>Online:</strong> ${info.onLine}<br>
                <strong>Cookies:</strong> ${info.cookieEnabled}<br>
                ${info.memory ? `<strong>Memory:</strong> ${info.memory.used}MB used / ${info.memory.total}MB total` : "<strong>Memory:</strong> Not available"}
            `;
      }

      // Feature Compatibility Test
      function testCompatibility() {
        updateStatus("compatibility-status", "running");

        const features = {
          fetch: typeof fetch !== "undefined",
          readableStream: typeof ReadableStream !== "undefined",
          textDecoder: typeof TextDecoder !== "undefined",
          performance:
            typeof performance !== "undefined" && "now" in performance,
          memory: typeof performance !== "undefined" && !!performance.memory,
          webStreams: "ReadableStream" in window && "WritableStream" in window,
          serviceWorker: "serviceWorker" in navigator,
          asyncIterator: typeof Symbol !== "undefined" && Symbol.asyncIterator,
        };

        const results = Object.entries(features)
          .map(
            ([feature, supported]) =>
              `${supported ? "‚úÖ" : "‚ùå"} ${feature}: ${supported}`
          )
          .join("\\n");

        document.getElementById("compatibility-results").textContent = results;
        document.getElementById("compatibility-results").style.display =
          "block";

        const allSupported = Object.values(features).every(Boolean);
        updateStatus(
          "compatibility-status",
          allSupported ? "success" : "error"
        );
      }

      // Frame Protocol Test
      function testFrameProtocol() {
        updateStatus("protocol-status", "running");
        const startTime = performance.now();

        try {
          // Create test frames
          const frames = [];
          for (let i = 0; i < 1000; i++) {
            frames.push({
              type: "generation",
              data: {
                delta: `Token ${i}`,
                total: `Content up to ${i}`,
                tokenCount: i,
              },
            });
          }

          const createTime = performance.now();

          // Encode frames
          const encoded = frames.map(frame =>
            new TextEncoder().encode(JSON.stringify(frame) + "\\n")
          );

          const encodeTime = performance.now();

          // Parse frames back
          const parsed = encoded.map(data => {
            const text = new TextDecoder().decode(data);
            return JSON.parse(text.trim());
          });

          const parseTime = performance.now();

          // Update metrics
          document.getElementById("frames-created").textContent = frames.length;
          document.getElementById("encoding-time").textContent =
            Math.round(encodeTime - createTime) + "ms";
          document.getElementById("parse-time").textContent =
            Math.round(parseTime - encodeTime) + "ms";
          document.getElementById("protocol-metrics").style.display = "grid";

          const results = `
Frame Protocol Test Results:
‚úÖ Created ${frames.length} frames in ${Math.round(createTime - startTime)}ms
‚úÖ Encoded ${encoded.length} frames in ${Math.round(encodeTime - createTime)}ms  
‚úÖ Parsed ${parsed.length} frames in ${Math.round(parseTime - encodeTime)}ms
‚úÖ Total test duration: ${Math.round(parseTime - startTime)}ms
‚úÖ Average time per frame: ${((parseTime - startTime) / frames.length).toFixed(2)}ms

Sample Frame:
${JSON.stringify(frames[0], null, 2)}
                `;

          document.getElementById("protocol-results").textContent = results;
          document.getElementById("protocol-results").style.display = "block";
          updateStatus("protocol-status", "success");
        } catch (error) {
          document.getElementById("protocol-results").textContent =
            `‚ùå Error: ${error.message}`;
          document.getElementById("protocol-results").style.display = "block";
          updateStatus("protocol-status", "error");
        }
      }

      // Network Conditions Test
      function testNetworkConditions(condition) {
        updateStatus("network-status", "running");

        const conditions = {
          fast: { delay: 0, dropRate: 0 },
          slow: { delay: 200, dropRate: 0 },
          unreliable: { delay: 50, dropRate: 0.1 },
        };

        const config = conditions[condition];
        simulateNetworkConditions(config, condition);
      }

      function simulateNetworkConditions(config, conditionName) {
        const startTime = performance.now();
        let processed = 0;
        let dropped = 0;

        // Simulate processing 100 frames
        const promises = [];
        for (let i = 0; i < 100; i++) {
          promises.push(
            new Promise(resolve => {
              setTimeout(
                () => {
                  if (Math.random() < config.dropRate) {
                    dropped++;
                  } else {
                    processed++;
                  }
                  resolve();
                },
                config.delay + Math.random() * config.delay
              );
            })
          );
        }

        Promise.all(promises).then(() => {
          const endTime = performance.now();
          const results = `
Network Simulation Results:
üìä Condition: ${conditionName}
‚úÖ Processed: ${processed} frames
üìâ Dropped: ${dropped} frames  
‚è±Ô∏è Duration: ${Math.round(endTime - startTime)}ms
üìà Success Rate: ${((processed / 100) * 100).toFixed(1)}%
üöÄ Throughput: ${((processed / (endTime - startTime)) * 1000).toFixed(1)} frames/sec
                `;

          document.getElementById("network-results").textContent = results;
          document.getElementById("network-results").style.display = "block";
          updateStatus("network-status", dropped < 50 ? "success" : "error");
        });
      }

      // Memory Performance Test
      function testMemoryPerformance() {
        updateStatus("memory-status", "running");

        const initialMemory = getMemoryUsage();
        const frames = [];

        // Create many frames to test memory usage
        for (let i = 0; i < 10000; i++) {
          frames.push({
            type: "generation",
            data: {
              delta: "Content chunk ".repeat(100), // ~1.3KB per frame
              total: "Total content",
              tokenCount: i,
            },
          });
        }

        const peakMemory = getMemoryUsage();

        // Clear frames
        frames.length = 0;

        // Force GC if available
        if (window.gc) window.gc();

        setTimeout(() => {
          const finalMemory = getMemoryUsage();

          document.getElementById("memory-used").textContent = finalMemory.used
            ? finalMemory.used + "MB"
            : "N/A";
          document.getElementById("memory-peak").textContent = peakMemory.used
            ? peakMemory.used + "MB"
            : "N/A";
          document.getElementById("gc-count").textContent = "1";
          document.getElementById("memory-metrics").style.display = "grid";

          const results = `
Memory Performance Test Results:
üìä Initial Memory: ${initialMemory.used || "N/A"}MB
üìà Peak Memory: ${peakMemory.used || "N/A"}MB  
üìâ Final Memory: ${finalMemory.used || "N/A"}MB
üíæ Memory Growth: ${
            peakMemory.used && initialMemory.used
              ? peakMemory.used - initialMemory.used + "MB"
              : "N/A"
          }
üßπ Memory Recovered: ${
            peakMemory.used && finalMemory.used
              ? peakMemory.used - finalMemory.used + "MB"
              : "N/A"
          }
                `;

          document.getElementById("memory-results").textContent = results;
          document.getElementById("memory-results").style.display = "block";
          updateStatus("memory-status", "success");
        }, 1000);
      }

      function testLargeContent() {
        updateStatus("memory-status", "running");

        const largeContent = "A".repeat(1000000); // 1MB string
        const startTime = performance.now();
        const initialMemory = getMemoryUsage();

        // Create large frame
        const frame = {
          type: "generation",
          data: {
            delta: largeContent,
            total: largeContent,
            tokenCount: largeContent.length,
          },
        };

        // Encode and decode
        const encoded = new TextEncoder().encode(JSON.stringify(frame) + "\\n");
        const decoded = new TextDecoder().decode(encoded);
        const parsed = JSON.parse(decoded.trim());

        const endTime = performance.now();
        const finalMemory = getMemoryUsage();

        const results = `
Large Content Test Results:
üìä Content Size: ${(largeContent.length / 1024 / 1024).toFixed(1)}MB
‚è±Ô∏è Processing Time: ${Math.round(endTime - startTime)}ms
üíæ Memory Impact: ${
          finalMemory.used && initialMemory.used
            ? finalMemory.used - initialMemory.used + "MB"
            : "N/A"
        }
‚úÖ Successfully processed large content frame
            `;

        document.getElementById("memory-results").textContent = results;
        document.getElementById("memory-results").style.display = "block";
        updateStatus("memory-status", "success");
      }

      // Live Streaming Test
      function testLiveStreaming() {
        updateStatus("streaming-status", "running");
        document.getElementById("streaming-button").disabled = true;

        const phases = [
          "loading-knowledge",
          "generating",
          "validating",
          "healing",
          "done",
        ];
        let currentPhase = 0;
        let frameCount = 0;
        let content = "";
        const startTime = performance.now();

        const phasesContainer = document.getElementById("streaming-phases");
        phasesContainer.style.display = "block";
        phasesContainer.innerHTML = phases
          .map(
            phase =>
              `<span class="phase-indicator phase-${phase}" id="phase-${phase}">${phase}</span>`
          )
          .join("");

        const contentContainer = document.getElementById("streaming-content");
        contentContainer.style.display = "block";
        contentContainer.textContent = "";

        document.getElementById("streaming-metrics").style.display = "grid";

        const interval = setInterval(() => {
          frameCount++;

          // Update phase
          if (frameCount % 20 === 0 && currentPhase < phases.length - 1) {
            currentPhase++;
          }

          // Simulate content generation
          if (
            phases[currentPhase] === "generating" ||
            phases[currentPhase] === "healing"
          ) {
            const chunk = `Content chunk ${frameCount}. `;
            content += chunk;
            contentContainer.textContent = content;
            contentContainer.scrollTop = contentContainer.scrollHeight;
          }

          // Update metrics
          const duration = performance.now() - startTime;
          document.getElementById("frames-received").textContent = frameCount;
          document.getElementById("stream-duration").textContent =
            Math.round(duration) + "ms";
          document.getElementById("frame-rate").textContent =
            Math.round((frameCount / duration) * 1000) + "/s";

          // Complete test
          if (frameCount >= 100 || currentPhase >= phases.length - 1) {
            clearInterval(interval);
            updateStatus("streaming-status", "success");
            document.getElementById("streaming-button").disabled = false;
            document.getElementById("streaming-button").textContent =
              "Test Complete";
          }
        }, 50); // 20 FPS
      }

      // Utility Functions
      function updateStatus(elementId, status) {
        const element = document.getElementById(elementId);
        element.className = `test-status status-${status}`;
        element.textContent = status.charAt(0).toUpperCase() + status.slice(1);
      }

      function getMemoryUsage() {
        if (performance.memory) {
          return {
            used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
            total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
          };
        }
        return { used: null, total: null };
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", function () {
        detectBrowserEnvironment();
      });
    </script>
  </body>
</html>
